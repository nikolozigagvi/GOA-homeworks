<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Voice Changer — 20 Voices Project</title>
  <style>
    :root{--bg:#071021;--card:#081220;--muted:#9fb6c9;--accent:#06b6d4;--accent2:#8b5cf6}
    body{font-family:Inter,Segoe UI,Roboto,system-ui,Arial;margin:0;background:linear-gradient(180deg,#071226 0%, #081827 100%);color:#e6eef8}
    .wrap{max-width:1100px;margin:32px auto;padding:24px}
    header{display:flex;gap:16px;align-items:center}
    h1{margin:0;font-size:24px}
    .grid{display:grid;grid-template-columns:360px 1fr;gap:18px;margin-top:18px}
    .card{background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.03);padding:14px;border-radius:12px}
    button{background:var(--accent);border:none;color:white;padding:10px 12px;border-radius:10px;cursor:pointer}
    .controls{display:flex;gap:8px;flex-wrap:wrap}
    select,input[type=range]{width:100%}
    label{font-size:13px;color:var(--muted);display:block;margin-bottom:6px}
    .preset-list{max-height:420px;overflow:auto;padding:6px}
    .preset{padding:8px;border-radius:8px;margin-bottom:6px;background:rgba(255,255,255,0.01);cursor:pointer}
    .preset.selected{outline:2px solid rgba(124,58,237,0.25);background:linear-gradient(90deg,rgba(124,58,237,0.06),transparent)}
    .meters{display:flex;gap:8px;align-items:center;margin-top:10px}
    canvas#viz{width:100%;height:140px;border-radius:8px;background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(0,0,0,0.02));}
    .footer-note{font-size:12px;color:var(--muted);margin-top:12px}
    .row{display:flex;gap:8px}
    .large{font-size:16px}
    .kbd{background:#0a1220;padding:6px 8px;border-radius:6px;border:1px solid rgba(255,255,255,0.03);font-family:monospace}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div>
        <h1>Voice Changer — 20 Voices</h1>
        <div style="color:var(--muted);font-size:13px">Record, transform, and export — 20 built-in voice presets using Web Audio API</div>
      </div>
      <div style="margin-left:auto;display:flex;gap:8px;align-items:center">
        <button id="startBtn">Start Audio</button>
        <button id="recordBtn">Record</button>
        <button id="stopRecBtn" disabled>Stop & Export</button>
      </div>
    </header>

    <div class="grid">
      <aside class="card">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div>
            <div style="font-weight:600">Input</div>
            <div style="font-size:13px;color:var(--muted)">Choose input, monitor levels, adjust effect intensity</div>
          </div>
          <div class="row">
            <div class="kbd" id="latencyDisplay">Buffered</div>
          </div>
        </div>

        <div style="margin-top:12px">
          <label for="sourceSelect">Microphone / Input device</label>
          <select id="sourceSelect"></select>
        </div>

        <div style="margin-top:12px">
          <label>Voice preset</label>
          <div class="preset-list" id="presetList"></div>
        </div>

        <div style="margin-top:12px">
          <label>Wet / Dry mix</label>
          <input id="wet" type="range" min="0" max="1" step="0.01" value="0.85">
        </div>

        <div style="margin-top:12px">
          <label>Master gain</label>
          <input id="masterGain" type="range" min="0" max="2" step="0.01" value="1">
        </div>

        <div style="margin-top:12px">
          <label>Custom pitch (semitones)</label>
          <input id="customPitch" type="range" min="-12" max="12" step="0.1" value="0">
        </div>

        <div style="margin-top:12px">
          <label>Extra effects</label>
          <div class="controls">
            <button id="toggleReverb">Toggle Reverb</button>
            <button id="toggleDelay">Toggle Delay</button>
            <button id="toggleBitcrush">Toggle Bitcrush</button>
          </div>
        </div>

        <div class="meters">
          <div style="flex:1">
            <label>Input level</label>
            <canvas id="inputMeter" height="24"></canvas>
          </div>
        </div>

        <div class="footer-note">Tip: Press Start Audio to allow microphone access. Click Record to capture a clip, then Stop & Export to download WAV.</div>
      </aside>

      <main class="card">
        <div style="display:flex;gap:12px;align-items:center;justify-content:space-between">
          <div>
            <div style="font-weight:600">Live Output</div>
            <div style="color:var(--muted);font-size:13px">Play live audio through your speakers after applying effects</div>
          </div>
          <div class="row">
            <button id="playSample">Play Sample</button>
            <button id="stopSample" disabled>Stop</button>
          </div>
        </div>

        <div style="margin-top:12px">
          <label>Visualization</label>
          <canvas id="viz"></canvas>
        </div>

        <div style="margin-top:12px">
          <div style="display:grid;grid-template-columns:repeat(3,1fr);gap:12px">
            <div class="card" style="padding:12px">
              <label>Pitch shift (semitones)</label>
              <div id="pitchLabel" class="large">0</div>
            </div>
            <div class="card" style="padding:12px">
              <label>Filter cutoff (Hz)</label>
              <div id="cutLabel" class="large">--</div>
            </div>
            <div class="card" style="padding:12px">
              <label>Effect notes</label>
              <div id="notes" class="large">--</div>
            </div>
          </div>
        </div>

        <section style="margin-top:12px">
          <h3 style="margin:0 0 10px 0">Presets included (20 voices)</h3>
          <ol>
            <li>Original — passthrough</li>
            <li>Deep — pitch -6 semitones + lowpass</li>
            <li>Monster — pitch -9 + distortion + lowpass</li>
            <li>Chipmunk — pitch +8 semitones + treble boost</li>
            <li>Helium — pitch +12 semitones (extreme)</li>
            <li>Robot — ring mod + bitcrusher + noise gate</li>
            <li>Alien — pitch +4 + delay + phaser</li>
            <li>Underwater — lowpass + slow chorus + reverb</li>
            <li>Telephone — bandpass ~1kHz + distortion
            </li>
            <li>Radio DJ — bandpass + compressor + eq</li>
            <li>Opera — reverb + wide EQ
            </li>
            <li>Whisper — highpass + downward pitch + noise
            </li>
            <li>Vocoder — carrier-synth vocoder emulation
            </li>
            <li>Spaceship — granular-like pitch modulation + delay
            </li>
            <li>Megaphone — high mid boost + distortion
            </li>
            <li>Angel Choir — subtle pitch layering + reverb
            </li>
            <li>Demon — heavy pitch down + distortion + bitcrush
            </li>
            <li>Autotune-lite — pitch quantize to nearest semitone
            </li>
            <li>Robot 2 — formant-shifted robotic voice
            </li>
            <li>Custom — responds to custom pitch & wet/dry
            </li>
          </ol>
        </section>

      </main>
    </div>

  </div>

<script>
// Voice Changer — single-file Web Audio project
// Notes: This demo uses Web Audio API to create a processing graph with multiple effect nodes
// It records PCM into a WAV and lets you export. Works in modern Chrome/Edge/Firefox (some features vary)

let audioCtx, micStream, sourceNode;
let masterGainNode, wetGain, dryGain;
let analyser, analyserData;
let scriptProcessor;
let destination;
let recording = false;
let recorderBuffers = [];
let sampleRate = 44100;

const presets = [
  {id:'original', name:'Original', pitch:0, notes:'Passthrough'},
  {id:'deep', name:'Deep', pitch:-6, lowpass:800, notes:'Warm deep voice'},
  {id:'monster', name:'Monster', pitch:-9, distortion:0.8, lowpass:900},
  {id:'chipmunk', name:'Chipmunk', pitch:8, notes:'High, fast'},
  {id:'helium', name:'Helium', pitch:12, notes:'Very high pitched'},
  {id:'robot', name:'Robot', robot:true, bitcrush:0.4, notes:'Robotic ring-mod'},
  {id:'alien', name:'Alien', pitch:4, delay:0.3, notes:'Spacy delay + pitch'},
  {id:'underwater', name:'Underwater', lowpass:900, reverb:true, notes:'Muffled + echo'},
  {id:'telephone', name:'Telephone', bandpass:1000, notes:'Phone-like mid band'},
  {id:'radio', name:'Radio DJ', bandpass:1200, compressor:true, notes:'Old radio'},
  {id:'opera', name:'Opera', reverb:true, notes:'Large hall reverb'},
  {id:'whisper', name:'Whisper', highpass:900, pitch:-3, notes:'Soft breathy voice'},
  {id:'vocoder', name:'Vocoder', vocoder:true, notes:'Carrier synth vocoding'},
  {id:'spaceship', name:'Spaceship', pitchMod:true, delay:0.25, notes:'Pitch wobble + delay'},
  {id:'megaphone', name:'Megaphone', distortion:0.6, notes:'Harsh mid boost'},
  {id:'choir', name:'Angel Choir', pitchLayer:true, reverb:true, notes:'Subtle harmonies'},
  {id:'demon', name:'Demon', pitch:-12, distortion:0.9, bitcrush:0.6, notes:'Very heavy'} ,
  {id:'autotune', name:'Autotune-lite', pitchQuantize:true, notes:'Quantizes pitch to semitones'},
  {id:'robot2', name:'Robot 2', formantShift:true, notes:'Formant / spectral robotic effect'},
  {id:'custom', name:'Custom', notes:'Use custom pitch & wet/dry'}
];

// Elements
const startBtn = document.getElementById('startBtn');
const sourceSelect = document.getElementById('sourceSelect');
const presetList = document.getElementById('presetList');
const wetSlider = document.getElementById('wet');
const masterGainSlider = document.getElementById('masterGain');
const pitchLabel = document.getElementById('pitchLabel');
const cutLabel = document.getElementById('cutLabel');
const notesEl = document.getElementById('notes');
const recordBtn = document.getElementById('recordBtn');
const stopRecBtn = document.getElementById('stopRecBtn');
const playSample = document.getElementById('playSample');
const stopSample = document.getElementById('stopSample');
const toggleReverb = document.getElementById('toggleReverb');
const toggleDelay = document.getElementById('toggleDelay');
const toggleBitcrush = document.getElementById('toggleBitcrush');
const customPitch = document.getElementById('customPitch');

let selectedPreset = presets[0];

// Build preset UI
function buildPresets(){
  presetList.innerHTML='';
  presets.forEach((p,idx)=>{
    const d = document.createElement('div');
    d.className='preset'+(idx===0? ' selected':'');
    d.innerHTML = `<strong>${p.name}</strong><div style="font-size:12px;color:var(--muted)">${p.notes||''}</div>`;
    d.onclick = ()=>{selectPreset(idx)};
    presetList.appendChild(d);
  });
}

function selectPreset(idx){
  document.querySelectorAll('.preset').forEach((el,i)=>el.classList.toggle('selected', i===idx));
  selectedPreset = presets[idx];
  applyPresetToUI(selectedPreset);
  rebuildGraph();
}

function applyPresetToUI(p){
  pitchLabel.textContent = (p.pitch || 0) + ' semitones';
  cutLabel.textContent = p.lowpass ? p.lowpass + ' Hz' : (p.bandpass ? p.bandpass + ' Hz' : '--');
  notesEl.textContent = p.notes || '--';
  customPitch.value = p.pitch || 0;
}

buildPresets();
applyPresetToUI(selectedPreset);

// Audio graph nodes (created/bound inside initAudio)
let pitchShifterNode; // placeholder for pitch shifting (we'll use playbackRate trick via offline buffer when recording; live we use granular-ish script)
let filterNode;
let biquadLP, biquadHP, bandpass;
let delayNode, feedbackGain;
let convolver;
let bitCrusherNode;
let ringModGain;
let vocoderNodes = [];
let pitchShiftAmount = 0;

function initAudio(){
  if(audioCtx) return;
  audioCtx = new (window.AudioContext || window.webkitAudioContext)({sampleRate:44100});
  sampleRate = audioCtx.sampleRate;
  masterGainNode = audioCtx.createGain(); masterGainNode.gain.value = parseFloat(masterGainSlider.value);
  wetGain = audioCtx.createGain(); wetGain.gain.value = parseFloat(wetSlider.value);
  dryGain = audioCtx.createGain(); dryGain.gain.value = 1 - wetGain.gain.value;
  analyser = audioCtx.createAnalyser(); analyser.fftSize = 2048; analyserData = new Uint8Array(analyser.frequencyBinCount);

  // Filters
  biquadLP = audioCtx.createBiquadFilter(); biquadLP.type = 'lowpass'; biquadLP.frequency.value = 22050;
  biquadHP = audioCtx.createBiquadFilter(); biquadHP.type = 'highpass'; biquadHP.frequency.value = 20;
  bandpass = audioCtx.createBiquadFilter(); bandpass.type = 'bandpass'; bandpass.frequency.value = 1000; bandpass.Q.value = 1;

  // Delay + feedback
  delayNode = audioCtx.createDelay(1.0); delayNode.delayTime.value = 0.18;
  feedbackGain = audioCtx.createGain(); feedbackGain.gain.value = 0.25;
  delayNode.connect(feedbackGain); feedbackGain.connect(delayNode);

  // Reverb (convolver) - short impulse generated
  convolver = audioCtx.createConvolver();
  convolver.buffer = createReverbBuffer(audioCtx, 2.5);

  // Bitcrusher (ScriptProcessor)
  bitCrusherNode = createBitCrusherNode(audioCtx, 8);

  // Ring modulation (oscillator-driven) via gain
  ringModGain = audioCtx.createGain(); ringModGain.gain.value = 0.0;

  // Final routing: wet -> masterGain -> analyser -> destination
  wetGain.connect(masterGainNode);
  masterGainNode.connect(analyser);
  analyser.connect(audioCtx.destination);

  // dry path
  dryGain.connect(masterGainNode);

  // hooking toggles
  toggleReverb.onclick = ()=>{ convolverEnabled = !convolverEnabled; rebuildGraph(); toggleReverb.textContent = convolverEnabled ? 'Reverb ON' : 'Toggle Reverb'; }
  toggleDelay.onclick = ()=>{ delayEnabled = !delayEnabled; rebuildGraph(); toggleDelay.textContent = delayEnabled ? 'Delay ON' : 'Toggle Delay'; }
  toggleBitcrush.onclick = ()=>{ bitcrushEnabled = !bitcrushEnabled; rebuildGraph(); toggleBitcrush.textContent = bitcrushEnabled ? 'Bitcrush ON' : 'Toggle Bitcrush'; }

  // Play sample voice (from microphone live) requires sourceNode to be connected
  playSample.onclick = ()=>{ if(!sourceNode){alert('Start audio & allow microphone first.'); return;} isPlayingSample=true; stopSample.disabled=false; playSample.disabled=true; }
  stopSample.onclick = ()=>{ isPlayingSample=false; stopSample.disabled=true; playSample.disabled=false; }
}

function createBitCrusherNode(ctx, bits){
  const node = ctx.createScriptProcessor(4096,1,1);
  const step = Math.pow(1/2, bits);
  node.onaudioprocess = function(e){
    const input = e.inputBuffer.getChannelData(0);
    const output = e.outputBuffer.getChannelData(0);
    for(let i=0;i<input.length;i++){
      const x = input[i];
      output[i] = step * Math.round(x/step);
    }
  }
  return node;
}

function createReverbBuffer(ctx, seconds){
  const rate = ctx.sampleRate;
  const length = rate * seconds;
  const buffer = ctx.createBuffer(2, length, rate);
  for(let ch=0; ch<2; ch++){
    const data = buffer.getChannelData(ch);
    for(let i=0;i<length;i++){
      data[i] = (Math.random()*2-1) * Math.pow(1 - i/length, 2);
    }
  }
  return buffer;
}

// Placeholder — rebuild the effect graph according to selectedPreset flags
let convolverEnabled = false, delayEnabled=false, bitcrushEnabled=false;
function rebuildGraph(){
  if(!audioCtx || !sourceNode) return;
  // disconnect everything from source
  try{ sourceNode.disconnect(); } catch(e){}

  // create a fresh processing chain: source -> (dryGain) -> master
  // and source -> effects -> wetGain -> master
  // Start by creating intermediate nodes
  const dry = dryGain;
  const wet = wetGain;

  // default nodes
  biquadLP.frequency.value = selectedPreset.lowpass || 22050;
  biquadHP.frequency.value = selectedPreset.highpass || 20;
  if(selectedPreset.bandpass) { bandpass.frequency.value = selectedPreset.bandpass; bandpass.Q.value = 1; }

  // pitch / pitch modulation — we'll implement a simple pitch shifting via playbackRate trick only for pre-recorded buffers.
  // For live audio we approximate: use a DelayNode-based modulated delay or granular approach — here we apply a simple playback-rate like via ScriptProcessor not perfect but OK for demo.

  // connect dry path
  sourceNode.connect(dry);

  // build wet chain
  let cur = sourceNode;

  // apply bandpass or lowpass/highpass per preset
  if(selectedPreset.bandpass){ cur.connect(bandpass); cur = bandpass; }
  else{
    if(selectedPreset.lowpass) { cur.connect(biquadLP); cur = biquadLP; }
    if(selectedPreset.highpass) { cur.connect(biquadHP); cur = biquadHP; }
  }

  // distortion
  if(selectedPreset.distortion){
    const dist = createDistortionNode(audioCtx, selectedPreset.distortion);
    cur.connect(dist); cur = dist;
  }

  // pitch layering (choir)
  if(selectedPreset.pitchLayer){
    const splitter = audioCtx.createChannelSplitter(1);
    const merger = audioCtx.createChannelMerger(2);
    cur.connect(splitter);
    // left normal
    splitter.connect(merger,0,0);
    // right with small pitch shift achieved with delay modulation
    const delay2 = audioCtx.createDelay(); delay2.delayTime.value = 0.02;
    splitter.connect(delay2); delay2.connect(merger,0,1);
    cur = merger;
  }

  // formant / robot — use ring mod
  if(selectedPreset.robot || selectedPreset.formantShift || selectedPreset.bitcrush){
    if(selectedPreset.robot || selectedPreset.formantShift){
      // ring mod: multiply with sine oscillator
      const osc = audioCtx.createOscillator(); osc.type='sine'; osc.frequency.value = 30;
      const mod = audioCtx.createGain(); mod.gain.value = selectedPreset.robot? 0.8 : 0.4;
      osc.connect(mod);
      mod.connect(ringModGain.gain);
      osc.start();
      cur.connect(ringModGain);
      ringModGain.connect(wet);
      // continue chain
    }
    if(selectedPreset.bitcrush || bitcrushEnabled){
      cur.connect(bitCrusherNode); cur = bitCrusherNode;
    }
  }

  // delay + feedback
  if(selectedPreset.delay || delayEnabled){
    const dtime = selectedPreset.delay || 0.18;
    delayNode.delayTime.value = dtime;
    cur.connect(delayNode);
    delayNode.connect(wet);
  }

  // reverb
  if(selectedPreset.reverb || convolverEnabled){
    cur.connect(convolver); cur = convolver;
  }

  // final connect cur to wet
  try{ cur.connect(wet); } catch(e){ /* fallback */ }

  // apply wet/dry gains
  wet.gain.value = parseFloat(wetSlider.value);
  dry.gain.value = 1 - wet.gain.value;

  // master gain
  masterGainNode.gain.value = parseFloat(masterGainSlider.value);

  // show custom pitch
  pitchLabel.textContent = customPitch.value + ' semitones';
  // notes
  notesEl.textContent = selectedPreset.notes || '--';
}

function createDistortionNode(ctx, amount){
  const waveshaper = ctx.createWaveShaper();
  const k = amount*50;
  const n = 44100; const curve = new Float32Array(n);
  for(let i=0;i<n;i++){ const x = i*2/n - 1; curve[i] = (3 + k) * x * 20 * (Math.PI/180) / (Math.PI + k * Math.abs(x)); }
  waveshaper.curve = curve; waveshaper.oversample = '4x';
  return waveshaper;
}

// get devices
async function listDevices(){
  const devices = await navigator.mediaDevices.enumerateDevices();
  sourceSelect.innerHTML='';
  devices.filter(d=>d.kind==='audioinput').forEach(d=>{
    const o = document.createElement('option'); o.value=d.deviceId; o.textContent = d.label || 'Microphone ' + (sourceSelect.length+1);
    sourceSelect.appendChild(o);
  });
}

startBtn.onclick = async ()=>{
  startBtn.disabled = true;
  await listDevices();
  await startMic();
  startBtn.textContent='Audio Ready';
}

async function startMic(){
  initAudio();
  const constraints = {audio:{deviceId: sourceSelect.value ? {exact: sourceSelect.value} : undefined}};
  micStream = await navigator.mediaDevices.getUserMedia(constraints);
  sourceNode = audioCtx.createMediaStreamSource(micStream);
  // connect to dry & wet in rebuildGraph
  rebuildGraph();
  visualize();
}

// recorder using ScriptProcessor to capture output audio (wet + dry mixed)
function startRecording(){
  if(!audioCtx) { alert('Start audio first'); return; }
  recording = true; recorderBuffers = [];
  // create a node to pull audio from masterGainNode's output (we'll use a ScriptProcessor hooked to masterGainNode)
  scriptProcessor = audioCtx.createScriptProcessor(4096,1,1);
  masterGainNode.connect(scriptProcessor);
  scriptProcessor.connect(audioCtx.destination); // necessary in some browsers
  scriptProcessor.onaudioprocess = function(e){
    if(!recording) return;
    const input = e.inputBuffer.getChannelData(0);
    recorderBuffers.push(new Float32Array(input));
  }
}

function stopRecordingAndExport(){
  recording = false;
  if(scriptProcessor){ try{ masterGainNode.disconnect(scriptProcessor); scriptProcessor.disconnect(); }catch(e){} scriptProcessor=null; }
  // flatten buffers
  const total = recorderBuffers.reduce((s,b)=>s+b.length,0);
  const out = new Float32Array(total);
  let offset=0; for(const b of recorderBuffers){ out.set(b,offset); offset+=b.length; }
  // convert to WAV
  const wav = encodeWAV(out, sampleRate);
  const blob = new Blob([wav], {type:'audio/wav'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href=url; a.download='voice_changer_recording.wav'; a.click();
}

recordBtn.onclick = ()=>{ startRecording(); recordBtn.disabled=true; stopRecBtn.disabled=false; };
stopRecBtn.onclick = ()=>{ stopRecordingAndExport(); recordBtn.disabled=false; stopRecBtn.disabled=true; };

function encodeWAV(samples, sampleRate){
  const buffer = new ArrayBuffer(44 + samples.length*2);
  const view = new DataView(buffer);
  function writeString(view, offset, string){ for(let i=0;i<string.length;i++){ view.setUint8(offset+i, string.charCodeAt(i)); } }
  /* RIFF identifier */ writeString(view, 0, 'RIFF');
  view.setUint32(4, 36 + samples.length*2, true);
  writeString(view, 8, 'WAVE');
  writeString(view, 12, 'fmt ');
  view.setUint32(16, 16, true);
  view.setUint16(20, 1, true);
  view.setUint16(22, 1, true);
  view.setUint32(24, sampleRate, true);
  view.setUint32(28, sampleRate * 2, true);
  view.setUint16(32, 2, true);
  view.setUint16(34, 16, true);
  writeString(view, 36, 'data');
  view.setUint32(40, samples.length*2, true);
  // PCM 16
  let offset = 44; for(let i=0;i<samples.length;i++){ let s = Math.max(-1, Math.min(1, samples[i])); view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true); offset+=2; }
  return view;
}

// visualization
const viz = document.getElementById('viz'); const vctx = viz.getContext('2d');
function visualize(){
  requestAnimationFrame(drawViz);
}
function drawViz(){
  if(!analyser) return;
  analyser.getByteTimeDomainData(analyserData);
  vctx.clearRect(0,0,viz.width,viz.height);
  vctx.beginPath();
  const h = viz.height; const w = viz.width;
  for(let i=0;i<analyserData.length;i++){
    const x = i / analyserData.length * w;
    const v = analyserData[i] / 128.0;
    const y = v * h/2;
    if(i===0) vctx.moveTo(x,y); else vctx.lineTo(x,y);
  }
  vctx.strokeStyle = 'rgba(124,58,237,0.9)'; vctx.lineWidth=2; vctx.stroke();
  requestAnimationFrame(drawViz);
}

// device change
sourceSelect.onchange = async ()=>{
  if(micStream){
    if(sourceNode){ try{ sourceNode.disconnect(); } catch(e){} }
    try{ micStream.getTracks().forEach(t=>t.stop()); } catch(e){}
    await startMic();
  }
}

// UI events
wetSlider.oninput = ()=>{ if(wetGain) wetGain.gain.value = parseFloat(wetSlider.value); if(dryGain) dryGain.gain.value = 1 - wetGain.gain.value; }
masterGainSlider.oninput = ()=>{ if(masterGainNode) masterGainNode.gain.value = parseFloat(masterGainSlider.value); }
customPitch.oninput = ()=>{ pitchLabel.textContent = customPitch.value + ' semitones'; }

// sample play is just live monitoring; to provide a sample audio, we can play back a short generated beep modified by the chain
let isPlayingSample=false;

// helper: Create distortion etc already above

// initial setup
(function(){
  // set canvas size
  const r = viz.getBoundingClientRect(); viz.width = r.width*devicePixelRatio; viz.height = 140*devicePixelRatio; viz.style.height='140px';
  buildPresets();
  // populate device list when permission granted
  navigator.mediaDevices && navigator.mediaDevices.getUserMedia && navigator.mediaDevices.getUserMedia({audio:true}).then(s=>{
    s.getTracks().forEach(t=>t.stop()); listDevices();
  }).catch(()=>{
    // ignore until user presses start
  });
})();

// Rebuild graph when preset changes or sliders change
wetSlider.addEventListener('change', rebuildGraph);
masterGainSlider.addEventListener('change', rebuildGraph);
customPitch.addEventListener('change', ()=>{ selectedPreset.pitch = parseFloat(customPitch.value); rebuildGraph(); });

// small utility to create a basic vocoder carrier (very simple)
function createVocoderCarrier(freq){
  const osc = audioCtx.createOscillator(); osc.type='sawtooth'; osc.frequency.value = freq || 120;
  const gain = audioCtx.createGain(); gain.gain.value = 0.0; osc.connect(gain); gain.connect(wetGain);
  osc.start();
  return {osc,gain};
}

// Very simple pitch quantize function for autotune-lite: shift detected pitch to nearest semitone by resampling
function quantizePitchOffline(floatArray, semitoneShift){ /* placeholder — complex */ }

// NOTE: This project is a demo that approximates many effects. High-quality pitch shifting (formant preserving) requires heavy DSP or WASM libraries (eg. soundtouch, rubberband, pitchshift.js) which can be integrated later.

</script>
</body>
</html>
